makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
xx <- 1:10.
makeVector(xx)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
yy <- 10:20
cachemean(yy)
yy <- 10:20
cachemean(xx)
y <- makeVector(xx)
cachemean(y)
cachemean(y)
y
y$getmean
y$setmean
y$setmean
y$setmean
obj <- makeVector(xx)
cachemean(obj)
yy <- 10:20
obj <- makeVector(yy)
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
size <- 10 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix
?inverse
size <- 4 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
mymatrix.inverse
mymatrix
mymatrix.inverse <- solve(mymatrix)
mymatrix
mymatrix.inverse
mymatrix
mymatrix.inverse <- solve(mymatrix)
mymatrix.inverse
1/0.9377756
makeCacheMatrix <- function(x = matrix()) {  #pass in matrix instead of x vector
matrix <- NULL # inverse matrix : where mean would be stored
set <- function(y) {  #stores the matrix and its inver
x <<- y   # storing orignal matrix x
matrix <<- NULL   #storing space inverse matrix in upper enviro
}
get <- function() x  #retrieves x the original matrix
setmatrix <- function(mean) matrix <<- mean  #sets the
getmatrix <- function() matrix  #called by cache solve,  returns the inverse matrix,
#but if inverse matrix has not been calculated yet, then it goes on to calculate after getting data
list(set = set, get = get,  #list of functions i guess...because they are only defined in this function
setmatrix = setmatrix,
getmatrix = getmatrix)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrix <- x$getmatrix() #gets inverse matrix using function of object X provided by prev function
if(!is.null(matrix)) {  #if inverse matrix value is not null it rereives the value from upper enviro
message("getting cached matrix data")
return(matrix) #return breaks function i think
}
data <- x$get() # If inverse matrix value is null, then it gets the vector from before get() of object
matrix <- solve(data, ...) #XXX this step must calculates the inverse matrix and stores as matrix variable
x$setmatrix(matrix)   #and so now matrix is cached, so before it returns the matrix, it sets the inverse matrix to mean in the upper enviro
matrix #returns m
}
}
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
makeCacheMatrix <- function(x = matrix()) {  #pass in matrix instead of x vector
matrix <- NULL # inverse matrix : where mean would be stored
set <- function(y) {  #stores the matrix and its inver
x <<- y   # storing orignal matrix x
matrix <<- NULL   #storing space inverse matrix in upper enviro
}
get <- function() x  #retrieves x the original matrix
setmatrix <- function(m) x <<-m   #sets the
getmatrix <- function() matrix  #called by cache solve,  returns the inverse matrix,
#but if inverse matrix has not been calculated yet, then it goes on to calculate after getting data
list(set = set, get = get,  #list of functions i guess...because they are only defined in this function
setmatrix = setmatrix,
getmatrix = getmatrix)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrix <- x$getmatrix() #gets inverse matrix using function of object X provided by prev function
if(!is.null(matrix)) {  #if inverse matrix value is not null it rereives the value from upper enviro
message("getting cached matrix data")
return(matrix) #return breaks function i think
}
data <- x$get() # If inverse matrix value is null, then it gets the vector from before get() of object
matrix <- solve(data, ...) #XXX this step must calculates the inverse matrix and stores as matrix variable
x$setmatrix(matrix)   #and so now matrix is cached, so before it returns the matrix, it sets the inverse matrix to mean in the upper enviro
matrix #returns m
}
mymatrix
mymatrix.inverse
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
makeCacheMatrix <- function(x = matrix()) {  #pass in matrix instead of x vector
matrix <- NULL # inverse matrix : where mean would be stored
set <- function(y) {  #stores the matrix and its inver
x <<- y   # storing orignal matrix x
matrix <<- NULL   #storing space inverse matrix in upper enviro
}
get <- function() x  #retrieves x the original matrix
setmatrix <- function(mean) matrix <<- mean  #sets the
getmatrix <- function() matrix  #called by cache solve,  returns the inverse matrix,
#but if inverse matrix has not been calculated yet, then it goes on to calculate after getting data
list(set = set, get = get,  #list of functions i guess...because they are only defined in this function
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## About cacheSolve. This function  retrieves the cached value of the inverse matrix, then checks whether the stored value is NULL. If the inverse matrix has already been calculated, it prints a message saying it is retrieving cached data, then returns the inverse matrix.  If the value is still NULL, the function retreives the value of the original matrix, stores it, and then calculates its inverse. before returning the inverted matrix, the function caches this information using the setmatrix function from makeCacheMatrix, then returns the newly calculated inverse matrix.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrix <- x$getmatrix() #gets inverse matrix using function of object X provided by prev function
if(!is.null(matrix)) {  #if inverse matrix value is not null it rereives the value from upper enviro
message("getting cached matrix data")
return(matrix) #return breaks function i think
}
data <- x$get() # If inverse matrix value is null, then it gets the vector from before get() of object
matrix <- solve(data, ...) #XXX this step must calculates the inverse matrix and stores as matrix variable
x$setmatrix(matrix)   #and so now matrix is cached, so before it returns the matrix, it sets the inverse matrix to mean in the upper enviro
matrix #returns m
}
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
#
special.solved.1 <- cacheSolve(special.matrix)
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
makeCacheMatrix <- function(x = matrix()) {  #pass in matrix instead of x vector
matrix <- NULL # inverse matrix : where mean would be stored
set <- function(y) {  #stores the matrix and its inver
x <<- y   # storing orignal matrix x
matrix <<- NULL   #storing space inverse matrix in upper enviro
}
get <- function() x  #retrieves x the original matrix
setmatrix <- function(m) matrix <<- m  #sets the
getmatrix <- function() matrix  #called by cache solve,  returns the inverse matrix,
#but if inverse matrix has not been calculated yet, then it goes on to calculate after getting data
list(set = set, get = get,  #list of functions i guess...because they are only defined in this function
setmatrix = setmatrix,
getmatrix = getmatrix)
}
## About cacheSolve. This function  retrieves the cached value of the inverse matrix, then checks whether the stored value is NULL. If the inverse matrix has already been calculated, it prints a message saying it is retrieving cached data, then returns the inverse matrix.  If the value is still NULL, the function retreives the value of the original matrix, stores it, and then calculates its inverse. before returning the inverted matrix, the function caches this information using the setmatrix function from makeCacheMatrix, then returns the newly calculated inverse matrix.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrix <- x$getmatrix() #gets inverse matrix using function of object X provided by prev function
if(!is.null(matrix)) {  #if inverse matrix value is not null it rereives the value from upper enviro
message("getting cached matrix data")
return(matrix) #return breaks function i think
}
data <- x$get() # If inverse matrix value is null, then it gets the vector from before get() of object
matrix <- solve(data, ...) #XXX this step must calculates the inverse matrix and stores as matrix variable
x$setmatrix(matrix)   #and so now matrix is cached, so before it returns the matrix, it sets the inverse matrix to mean in the upper enviro
matrix #returns m
}
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
special.solved.1 <- cacheSolve(special.matrix)
#
# this should take long, since it's the first go
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
special.solved.3 <- cacheSolve(special.matrix, rep(4,1000))
identical(special.solved.1, special.solved.3)
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
#
# now solve the matrix via the cache-method
#
special.matrix   <- makeCacheMatrix(mymatrix)
#
# this should take long, since it's the first go
special.solved.1 <- cacheSolve(special.matrix)
#
# this should be lightning fast
special.solved.2 <- cacheSolve(special.matrix)
#
# check if all solved matrices are identical
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
#
special.solved.3 <- cacheSolve(special.matrix, rep(4,1000))
# in this case you should NOT see the "getting cached data" message
# because the parameters to CacheSolve changed even if the matrix is the same!
identical(special.solved.1, special.solved.3)
# should return FALSE
special.solved.4 <- cacheSolve(special.matrix, rep(4,1000))
# now you should get the cached result again
identical(special.solved.3, special.solved.4)
# should return TRUE
iden <- mymatrix %*% special.solved.1
round(iden[1:5,1:5])
mymatrix2 <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse2 <- solve(mymatrix2)
# Change the matrix inside special.matrix to mymatrix2
special.matrix$set(mymatrix2)
# This should take long, since it's the first go and should not come from cache
# If the result come from cache, your code do not detect the matrix change correctly
# Most likely, your set fucntion is not working correctly.
special.solved.3 <- cacheSolve(special.matrix)
# this should be lightning fast and come from cache
special.solved.4 <- cacheSolve(special.matrix)
# check if all solved matrices are identical
identical(mymatrix.inverse2, special.solved.3) & identical(mymatrix.inverse2, special.solved.4)
# should return TRUE
mymatrix2 <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix2.inverse <- solve(mymatrix2)
#Then modify the contents of the the special matrix using the 'set' function:
special.matrix$set(mymatrix2)
#Now use cacheSolve. You should NOT see 'getting cached data' in your console because the matrix contents are now modified:
special.solved.3 = cacheSolve(special.matrix)
#The following should return FALSE, because now you have a new inverse value:
print(identical(mymatrix.inverse, special.solved.3))
#But this should return TRUE:
print(identical(mymatrix2.inverse, special.solved.3))
#If you cacheSolve again, you should now see 'getting cached data' in the console.
special.solved.4 = cacheSolve(special.matrix)
#And this should return TRUE:
print(identical(mymatrix2.inverse, special.solved.4))
